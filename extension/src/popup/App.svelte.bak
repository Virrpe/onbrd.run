<script lang="ts">
  import { onMount } from 'svelte';
  import { renderReport } from '@onboarding-audit/report';
  import Paywall from '../lib/paywall.svelte';

  // analytics-probe: Import analytics tracking
  let analyticsEnabled = false;
  let trackEvent: ((eventName: string, payload?: Record<string, any>) => Promise<void>) | null = null;
  let eventNames: any = null;

  let telemetryOptIn = false;
  let aiOptIn = false;
  let device: 'desktop'|'mobile' = 'desktop';
  let cohort: 'global'|'saas'|'ecommerce'|'content' = 'global';
  let benchmark: { percentile?: number; median?: number; count?: number } | null = null;
  let score: number | null = null;
  let fixes: Array<{id:string; fix:string; weight:number}> = [];

  // Paywall state
  let showPaywall = false;
  let paywallVariant: 'benchmarks' | 'compliance' = 'benchmarks';
  let currentIntent: { kind: 'export' | 'artifact', payload?: any } | null = null;
  let isPollingEntitlements = false;
  let paymentProcessingMessage = '';

  onMount(async () => {
    const s = await chrome.storage.sync.get({
      telemetry_opt_in: false,
      ai_opt_in: false,
      onbrd_device: 'desktop',
      onbrd_cohort: 'global'
    });
    telemetryOptIn = s.telemetry_opt_in;
    aiOptIn = s.ai_opt_in;
    device = s.onbrd_device;
    cohort = s.onbrd_cohort;
    
    // Check for payment success return
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has('paid')) {
      handlePaymentReturn();
    }
    
    // analytics-probe: Initialize analytics tracking
    try {
      // Check if analytics is enabled via feature flag
      const response = await fetch('/lib/featureFlags.ts');
      if (response.ok) {
        analyticsEnabled = true; // Simplified for extension context
        // Import analytics functions dynamically
        const analyticsModule = await import('../../../site/lib/analytics.ts');
        trackEvent = analyticsModule.track;
        eventNames = analyticsModule.EVENT_NAMES;
      }
    } catch (error) {
      console.warn('Analytics initialization failed:', error);
      analyticsEnabled = false;
    }
  });

  function savePrefs() {
    chrome.storage.sync.set({
      telemetry_opt_in: telemetryOptIn,
      ai_opt_in: aiOptIn,
      onbrd_device: device,
      onbrd_cohort: cohort
    });
  }

  async function handlePaymentReturn() {
    isPollingEntitlements = true;
    paymentProcessingMessage = 'Payment received! Checking access...';
    
    // Poll entitlements up to 5 times with 1s interval
    for (let i = 0; i < 5; i++) {
      try {
        const response = await fetch('/api/v1/entitlements', {
          credentials: 'include'
        });
        
        if (response.ok) {
          const entitlements = await response.json();
          if (entitlements.plan_status === 'active') {
            // Payment successful, execute original intent
            isPollingEntitlements = false;
            paymentProcessingMessage = '';
            
            // Track checkout success
            if (analyticsEnabled && trackEvent && eventNames) {
              try {
                await trackEvent(eventNames.CHECKOUT_SUCCESS, {
                  variant: paywallVariant,
                  device,
                  cohort
                });
              } catch (error) {
                console.warn('Analytics tracking failed:', error);
              }
            }
            
            // Execute original intent
            if (currentIntent) {
              if (currentIntent.kind === 'export') {
                await executeExport();
              } else if (currentIntent.kind === 'artifact') {
                await executeArtifact();
              }
            }
            
            // Close paywall if open
            showPaywall = false;
            currentIntent = null;
            return;
          }
        }
      } catch (error) {
        console.warn('Error polling entitlements:', error);
      }
      
      // Wait 1 second before next poll
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
    
    // If still not active after polling
    isPollingEntitlements = false;
    paymentProcessingMessage = 'Payment is processingâ€”try again in a few seconds.';
  }

  async function executeExport() {
    try {
      const response = await fetch('/api/v1/benchmarks/export.csv', {
        credentials: 'include'
      });
      
      if (response.ok) {
        const blob = await response.blob();
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'onbrd-benchmarks.csv';
        a.click();
        URL.revokeObjectURL(url);
      } else if (response.status === 402) {
        // Should not happen after payment, but handle gracefully
        console.warn('Still not entitled after payment');
      }
    } catch (error) {
      console.error('Export failed:', error);
    }
  }

  async function executeArtifact() {
    try {
      // For artifact creation, we need audit data
      const auditData = {
        score,
        fixes,
        benchmark,
        device,
        cohort
      };
      
      const response = await fetch('/api/v1/artifacts', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify(auditData)
      });
      
      if (response.ok) {
        const result = await response.json();
        if (result.downloadUrl) {
          window.open(result.downloadUrl, '_blank');
        }
      } else if (response.status === 402) {
        // Should not happen after payment, but handle gracefully
        console.warn('Still not entitled after payment');
      }
    } catch (error) {
      console.error('Artifact creation failed:', error);
    }
  }

  async function handlePaywalledAction(kind: 'export' | 'artifact') {
    // Track attempt
    if (analyticsEnabled && trackEvent && eventNames) {
      try {
        if (kind === 'export') {
          await trackEvent(eventNames.EXPORT_ATTEMPT, {
            variant: 'benchmarks',
            device,
            cohort
          });
        } else {
          await trackEvent(eventNames.ARTIFACT_ATTEMPT, {
            variant: 'evidence',
            device,
            cohort
          });
        }
      } catch (error) {
        console.warn('Analytics tracking failed:', error);
      }
    }
    
    // Store current intent
    currentIntent = { kind };
    paywallVariant = kind === 'export' ? 'benchmarks' : 'compliance';
    
    // Show paywall
    showPaywall = true;
    
    // Track paywall shown
    if (analyticsEnabled && trackEvent && eventNames) {
      try {
        await trackEvent(eventNames.PAYWALL_SHOWN, {
          reason: 'payment_required',
          variant: paywallVariant,
          device,
          cohort
        });
      } catch (error) {
        console.warn('Analytics tracking failed:', error);
      }
    }
  }

  async function handleCheckout() {
    // Track checkout click
    if (analyticsEnabled && trackEvent && eventNames) {
      try {
        await trackEvent(eventNames.CHECKOUT_CLICK, {
          source: 'paywall_modal',
          variant: paywallVariant,
          device,
          cohort
        });
      } catch (error) {
        console.warn('Analytics tracking failed:', error);
      }
    }
    
    try {
      const returnTo = encodeURIComponent(window.location.href.split('?')[0] + '?paid=1');
      const response = await fetch('/api/v1/billing/checkout?returnTo=' + returnTo, {
        credentials: 'include'
      });
      
      if (response.ok) {
        const checkoutUrl = await response.text();
        window.open(checkoutUrl, '_blank');
      } else {
        const errorData = await response.json();
        if (errorData.reason === 'missing_env') {
          console.log('Stripe not configured. Please set STRIPE_SECRET_KEY and STRIPE_PRICE_ID environment variables.');
          paymentProcessingMessage = 'Checkout not configured. Please contact support.';
        } else {
          console.error('Checkout failed:', errorData);
          paymentProcessingMessage = 'Checkout failed. Please try again.';
        }
      }
    } catch (error) {
      console.error('Checkout error:', error);
      paymentProcessingMessage = 'Checkout error. Please try again.';
    }
  }

  function selectDevice(d: string) {
    device = d as 'desktop' | 'mobile';
    savePrefs();
  }

  function selectCohort(c: string) {
    cohort = c as 'global' | 'saas' | 'ecommerce' | 'content';
    savePrefs();
  }

  async function runAudit() {
    // analytics-probe: Track audit events
    if (analyticsEnabled && trackEvent && eventNames) {
      try {
        await trackEvent(eventNames.AUDIT_RUN, {
          device,
          cohort,
          telemetryOptIn,
          aiOptIn
        });
        // Also track legacy AUDIT_START for backward compatibility
        await trackEvent(eventNames.AUDIT_START, {
          device,
          cohort,
          telemetryOptIn,
          aiOptIn
        });
      } catch (error) {
        console.warn('Analytics tracking failed:', error);
      }
    }
    
    const resp = await chrome.runtime.sendMessage({ type: 'ONBRD_RUN_AUDIT_ACTIVE_TAB', device, cohort });
    if (resp?.error) {
      console.error(resp.error);
      return;
    }
    const { audit, benchmark: bmk } = resp ?? {};
    score = audit?.score ?? null;
    fixes = audit?.topFixes ?? [];
    benchmark = telemetryOptIn ? (bmk ?? null) : null;
  }

  function tsStamp(d=new Date()){const p=(n:number)=>n.toString().padStart(2,'0');return `${d.getFullYear()}${p(d.getMonth()+1)}${p(d.getDate())}${p(d.getHours())}${p(d.getMinutes())}`;}
  async function exportHtml() {
    // analytics-probe: Track export click event
    if (analyticsEnabled && trackEvent && eventNames) {
      try {
        await trackEvent(eventNames.EXPORT_CLICK, {
          fileType: 'html-report',
          hasScore: score !== null,
          device,
          cohort
        });
      } catch (error) {
        console.warn('Analytics tracking failed:', error);
      }
    }
    
    const [{ url }] = await chrome.tabs.query({ active: true, currentWindow: true });
    const host = (url || '').replace(/^https?:\/\//,'').replace(/^www\./,'').split(/[/?#]/)[0] || 'site';
    
    // Create a complete audit object for renderReport
    const auditData = {
      id: 'popup-export-' + Date.now(),
      url: url || 'https://example.com',
      timestamp: new Date().toISOString(),
      scores: score ? {
        overall: score,
        h_cta_above_fold: 0,
        h_steps_count: 0,
        h_copy_clarity: 0,
        h_trust_markers: 0,
        h_perceived_signup_speed: 0
      } : {
        overall: 0,
        h_cta_above_fold: 0,
        h_steps_count: 0,
        h_copy_clarity: 0,
        h_trust_markers: 0,
        h_perceived_signup_speed: 0
      },
      heuristics: {
        h_cta_above_fold: { detected: false, position: 0, element: 'div' },
        h_steps_count: { total: 0, forms: 0, screens: 0 },
        h_copy_clarity: { avg_sentence_length: 0, passive_voice_ratio: 0, jargon_density: 0 },
        h_trust_markers: { total: 0, testimonials: 0, security_badges: 0, customer_logos: 0 },
        h_perceived_signup_speed: { estimated_seconds: 0, form_fields: 0, required_fields: 0 }
      },
      recommendations: fixes.map(fix => ({
        heuristic: fix.id,
        priority: 'high' as const,
        description: fix.fix,
        fix: fix.fix
      })),
      benchmark: benchmark || undefined,
      pageHost: host,
      createdAt: new Date().toISOString()
    };
    
    const html = renderReport(auditData);
    const blob = new Blob([html], { type: 'text/html' });
    const fn = `onboarding-audit-${host}-${tsStamp()}.html`;
    const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = fn; link.click();
  }

  async function exportCsv() {
    await handlePaywalledAction('export');
  }

  async function generateArtifact() {
    await handlePaywalledAction('artifact');
  }
</script>

<div class="p-4 w-[360px] text-sm">
  <header class="flex items-center gap-2 mb-3">
    <img src="./../../icons/icon16.png" width="20" height="20" alt="Onbrd" />
    <h1 class="font-brand text-sm tracking-tight text-ink-900">Onbrd</h1>
  </header>

  <div class="mb-3 flex items-center gap-2">
    <label class="inline-flex items-center gap-1">
      <input type="checkbox" bind:checked={telemetryOptIn} on:change={savePrefs} />
      <span>Share anonymous benchmarks</span>
    </label>
  </div>

  <div class="mb-4 p-3 bg-gray-50 rounded-lg border border-gray-200">
    <div class="flex items-center gap-2 mb-2">
      <label class="inline-flex items-center gap-1">
        <input type="checkbox" bind:checked={aiOptIn} on:change={savePrefs} />
        <span class="font-medium">Enable AI insights</span>
      </label>
    </div>
    <div class="text-xs text-gray-600 leading-relaxed">
      When enabled, AI features send page content to cloud services for analysis.
      This includes text, structure, and metadata from the audited page.
      AI insights provide enhanced recommendations but require internet connectivity.
    </div>
  </div>

  <div class="mb-3 flex flex-wrap gap-2">
    <div class="text-xs text-ink-500">Device</div>
    {#each ['desktop','mobile'] as d}
      <button class="chip"
        class:bg-brand-100={device===d} class:text-brand-800={device===d}
        on:click={() => selectDevice(d)}>{d}</button>
    {/each}
  </div>

  <div class="mb-4 flex flex-wrap gap-2">
    <div class="text-xs text-ink-500">Cohort</div>
    {#each ['global','saas','ecommerce','content'] as c}
      <button class="chip"
        class:bg-brand-100={cohort===c} class:text-brand-800={cohort===c}
        on:click={() => selectCohort(c)}>{c}</button>
    {/each}
  </div>

  <div class="flex gap-2 mb-3">
    <button class="btn-primary flex-1" on:click={runAudit}>Run Audit</button>
    <button class="chip" on:click={exportHtml}>Export HTML</button>
  </div>

  <div class="flex gap-2 mb-3">
    <button class="chip" on:click={exportCsv}>Export CSV</button>
    <button class="chip" on:click={generateArtifact}>Evidence Pack</button>
  </div>

  {#if score !== null}
    <div class="mb-2 text-lg font-semibold">{score}</div>
    {#if benchmark}
      {#if benchmark.count && benchmark.count >= 200 && benchmark.percentile !== undefined}
        <div class="text-xs text-gray-600">Top {benchmark.percentile}% of {benchmark.count} peers (median {benchmark.median}) â€¢ {cohort} â€¢ {device}</div>
      {:else}
        <div class="text-xs text-gray-500">Benchmark buildingâ€¦</div>
      {/if}
    {:else}
      <div class="text-xs text-gray-500">Benchmark offline</div>
    {/if}

    <div class="mt-3">
      <div class="text-xs uppercase text-gray-400 mb-1">Fix these to improve</div>
      <ul class="list-disc pl-5 space-y-1">
        {#each fixes.slice(0,3) as f}
          <li><span class="font-medium">{f.id}</span> â€” {f.fix}</li>
        {/each}
      </ul>
    </div>
  {/if}

  {#if showPaywall}
    <Paywall variant={paywallVariant} onClose={() => showPaywall = false} onCheckout={handleCheckout} />
  {/if}

  {#if paymentProcessingMessage}
    <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div class="bg-white rounded-lg p-6 max-w-md w-full mx-4">
        <div class="text-center">
          <div class="text-lg font-semibold mb-2">Processing Payment</div>
          <div class="text-gray-600">{paymentProcessingMessage}</div>
          {#if isPollingEntitlements}
            <div class="mt-4">
              <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
            </div>
          {/if}
        </div>
      </div>
    </div>
  {/if}
</div>